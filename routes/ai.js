/**
 * FILE PATH: backend/routes/ai.js
 * * Handles API requests for real-time and post-session AI analysis using AIService.
 */
import express from 'express';
import Session from '../models/Session.js';
import aiService from '../services/aiService.js'; // ⭐️ Use the previously defined AIService
import { authenticateToken } from '../middleware/auth.js';
import { body, validationResult } from 'express-validator';

const router = express.Router();

// =========================================================
// 1. CHAT/STUDY ASSISTANT
// =========================================================
router.post(
  '/chat',
  authenticateToken,
  [
    body('prompt').trim().notEmpty().withMessage('Prompt is required'),
    body('history').optional().isArray(),
    body('sessionId').optional().notEmpty(),
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) return res.status(400).json({ errors: errors.array() });

      const { prompt, history, sessionId } = req.body;
      
      // ⭐️ Placeholder for actual chat implementation in AIService
      // The AIService implementation would handle the LLM call, context, and history management.
      const chatResponse = {
        response: `Hello ${req.user.name}. Your prompt: "${prompt}" has been received. This feature requires a dedicated AI chat implementation in aiService.`,
        suggested_followups: ["Summarize my last session", "Generate flashcards from my notes"],
      };
      
      // In a real implementation:
      // const chatResponse = await aiService.processChat({ prompt, history, userId: req.user._id, sessionId });

      res.json(chatResponse);
    } catch (error) {
      console.error('Chat error:', error);
      res.status(500).json({ message: 'AI chat failed', error: error.message });
    }
  }
);


// =========================================================
// 2. SUMMARIZE TEXT (Student notes, highlighted content)
// =========================================================
router.post(
  '/summarize',
  authenticateToken,
  [
    body('text').trim().isLength({ min: 50 }).withMessage('Text must be at least 50 characters for summarization'),
    body('summaryType').optional().isIn(['brief', 'detailed', 'bullet', 'executive']),
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) return res.status(400).json({ errors: errors.array() });

      const { text, summaryType } = req.body;
      const summaryResult = await aiService.generateSummary(text, summaryType);
      
      res.json(summaryResult);
    } catch (error) {
      console.error('Summarization error:', error);
      res.status(500).json({ message: 'Failed to generate summary', error: error.message });
    }
  }
);


// =========================================================
// 3. GENERATE STUDY QUESTIONS
// =========================================================
router.post(
  '/questions',
  authenticateToken,
  [
    body('text').trim().isLength({ min: 100 }).withMessage('Text must be at least 100 characters to generate questions'),
    body('count').optional().isInt({ min: 1, max: 20 }),
    body('difficulty').optional().isIn(['easy', 'medium', 'hard']),
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) return res.status(400).json({ errors: errors.array() });

      const { text, count, difficulty } = req.body;
      const questions = await aiService.generateQuestions(text, difficulty, count);
      
      res.json({ questions });
    } catch (error) {
      console.error('Question generation error:', error);
      res.status(500).json({ message: 'Failed to generate questions', error: error.message });
    }
  }
);


// =========================================================
// 4. GET POST-SESSION RECOMMENDATIONS
// =========================================================
router.get(
  '/recommendations/:sessionId',
  authenticateToken,
  async (req, res, next) => {
    try {
      const session = await Session.findById(req.params.sessionId);
      if (!session) return res.status(404).json({ message: 'Session not found' });

      // Ensure the user owns the session or is a teacher
      if (
        req.user.role === 'student' && 
        session.student_id.toString() !== req.user._id.toString()
      ) {
        return res.status(403).json({ message: 'Access denied to this session' });
      }

      // The recommendations are generated by aiService.runPostSessionAnalysis 
      // and stored on the Session model (ai_recommendations)
      if (!session.ai_recommendations) {
        // If not found, you can optionally kick off the analysis again (non-blocking)
        aiService.runPostSessionAnalysis(session._id).catch(err => console.error("Re-run analysis failed:", err));
        return res.status(202).json({ 
            message: 'Recommendations are still being generated. Please try again shortly.',
            status: 'processing'
        });
      }

      res.json(session.ai_recommendations);

    } catch (error) {
      console.error('Get recommendations error:', error);
      next(error);
    }
  }
);


// =========================================================
// 5. GET SESSION INSIGHTS (using Claude for deeper analysis)
// =========================================================
router.get(
  '/insights/:sessionId',
  authenticateToken,
  async (req, res, next) => {
    try {
      const session = await Session.findById(req.params.sessionId);
      if (!session) return res.status(404).json({ message: 'Session not found' });

      // Permission check (student owns it or user is teacher)
      if (
        req.user.role === 'student' && 
        session.student_id.toString() !== req.user._id.toString()
      ) {
        return res.status(403).json({ message: 'Access denied to this session' });
      }
      
      // Get the final metrics which are needed for insights
      if (!session.metrics || !session.metrics.duration_seconds) {
          return res.status(400).json({ message: 'Session metrics not yet calculated. End the session completely.' });
      }
      
      const insights = await aiService.generateSessionInsights(session.metrics);

      res.json(insights);

    } catch (error) {
      console.error('Get session insights error:', error);
      next(error);
    }
  }
);

export default router;